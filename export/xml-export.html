<%shared>
our $titlestr;
</%shared>

<%method title>
Lojban XML Dictionary Generation
</%method>

<%args>
$lang => undef
$bot_key => undef
$positive_scores_only => 1
$all_defs => 0
</%args>

<%init>
our($dbh,%session);
use File::Temp qw{ tempfile tempdir };
use POSIX;
use Captcha::reCAPTCHA;

my $c = Captcha::reCAPTCHA->new;
my $recaptcha_response = $ARGS{'g-recaptcha-response'};
</%init>

% if( ! defined($session{'userid'}) && ! defined($recaptcha_response) && $bot_key ne 'z2BsnKYJhAB0VNsl' ) {
<html><head></head>
<body>
<h1>Login To Skip This Step</h1>
<form method="post" action="xml-export.html">
  <input type="hidden" name="lang" value="<% $lang %>" />
<%perl>
# Don't bother making logged in users captcha
if( ! defined($session{'userid'}) ) {
    # reCaptcha Output form
    # Public key
    print $c->get_html_v2( '6Lf1RwAAAAAAANZIsJS0Ra-ycdARlCNMTzOkkC-v' );
}
</%perl>
  <input type="submit" />
</form>
</body>
</html>

<%perl>
} else {
    my $result;

    # Verify submission
    # Don't bother making logged in users captcha
    if( ! defined($session{'userid'}) && $bot_key ne 'z2BsnKYJhAB0VNsl' ) {
	$result = $c->check_answer_v2(
	    # Private key
	    '6Lf1RwAAAAAAAP6IcWCSHjdtZ5yh1y2muHE7f1Zy', $recaptcha_response, $ENV{'REMOTE_ADDR'}
	);
    }

    if ( $bot_key eq 'z2BsnKYJhAB0VNsl' || $result->{is_valid} || defined($session{'userid'}) ) {
      my $langid = $dbh->selectrow_array("SELECT langId FROM languages WHERE
          tag=?", undef, $lang);

      if( $langid !~ m{^[0-9]+$} ) {
	</%perl>
	<font size="+3">
        Bad language tag '<% $lang %>'.
	</font>
	<%perl>
        return;
      }

      $r->content_type('application/xml; charset=utf-8');
      $r->headers_out->add('Content-Disposition' => "attachment; filename=\"jbovlaste-$lang.xml\"");

      our $unofficialwarning = 'unofficial="true" ';
      my $langrealname = $dbh->selectrow_array("SELECT realname FROM languages WHERE tag=?", undef, $lang);

      print qq{<?xml version="1.0" encoding="UTF-8"?>\n};
      print qq{<?xml-stylesheet type="text/xsl" href="jbovlaste.xsl"?>\n};
      print qq{<dictionary>\n};

      my $all_votes = $dbh->selectall_hashref("SELECT definitionid, userid, value FROM definitionvotes WHERE langid=?",
              ['definitionid', 'userid', 'value'], undef, $langid);

      my $keywords = fetchkeywords($dbh, $langid, $all_defs);

      # Print the lojban -> foo section
      my $sth = selectvalsi($dbh, $langid, $all_defs);
      print qq{<direction from="lojban" to="$langrealname">};

      if( $all_defs ) {
        # In the all_defs case we need to gather multiple results
        # into one thing for valsitag, which gets a bit complicated
        my $valsirows = [];
        my $lastrow = {};

        while(defined(my $valsirow=$sth->fetchrow_hashref)) {
            # If this one is the same as the previous one,
            # add it to the list, otherwise print out what
            # we gathered.
            if( $valsirow->{word} eq $lastrow->{word} ) {
                push @$valsirows, $valsirow;
            } else {
                # This if is just to stop us from printing an empty word at the beginning
                if( scalar @{$valsirows} > 0 ) {
                    my $tag = valsitag($valsirows, $keywords, $positive_scores_only, $all_votes, $all_defs);
                    if( $tag ) {
                        print "$tag\n";
                    }
                }

                # Set up the next one
                $valsirows = [$valsirow];
            }

            $lastrow = $valsirow;
        }

        # Finish the last one
        my $tag = valsitag($valsirows, $keywords, $positive_scores_only, $all_votes, $all_defs);
        if( $tag ) {
            print "$tag\n";
        }

      } else {
        while(defined(my $valsirow=$sth->fetchrow_hashref))
        {
            my $tag = valsitag([$valsirow], $keywords, $positive_scores_only, $all_votes, $all_defs);
            if( $tag ) {
                print "$tag\n";
            }
        }
      }
      print qq{</direction>};

      # Print the foo -> lojban section
      print qq{<direction from="$langrealname" to="lojban">};
      $sth = selectwords($dbh, $langid, $all_defs);
      while(defined(my $nlwordrow = $sth->fetchrow_hashref)) {
          my $tag = nlwordtag($nlwordrow, $positive_scores_only, $all_votes);
          if( $tag ) {
              print "$tag\n";
          }
      }
      print qq{</direction>};

      print qq{</dictionary>\n};

      ####

      sub fetchkeywords {
          my ($dbh, $langid, $all_defs) = @_;

          my $sth = selectkeywords($dbh, $langid, $all_defs);
          my %keywords;
          while(defined(my $kwrow = $sth->fetchrow_hashref)) {
              my $definitionid = $kwrow->{'definitionid'};
              $keywords{$definitionid} ||= [];
              push @{$keywords{$definitionid}}, $kwrow;
          }
          return \%keywords;
      }

      # We could theoretically use bestguesses to pull scores
      # in the all_defs=0 case and only use this for the
      # all_defs=1 case, but it's not actually that slow
      # so it's not worth all the conditional code
      sub get_score {
          my ($defid, $all_votes) = @_;

          use List::Util qw/sum/;

          if( defined( $all_votes->{$defid} ) ) {
              return sum (map { keys %{$_} } values %{$all_votes->{$defid}});
          } else {
              return 0;
          }
      }

      sub selectkeywords {
          my ($dbh, $langid, $all_defs) = @_;

          my $defs_table="valsibestdefinitions def";
          if( $all_defs ) {
              $defs_table="definitions def";
          }

          my $sth = $dbh->prepare("
                  SELECT def.definitionid, nlw.word, nlw.meaning, km.place
                  FROM $defs_table
                  JOIN keywordmapping km
                  ON km.definitionid = def.definitionid
                  JOIN natlangwords nlw
                  ON nlw.wordid = km.natlangwordid
                  WHERE def.langid=$langid
                  ORDER BY def.definitionid, km.place, nlw.word, nlw.meaning
                  ");
          $sth->execute();

          return $sth;
      }

      # Get the valsi list.
      sub selectvalsi {
        my ($dbh, $langid, $all_defs) = @_;

        my $defs_table="valsibestdefinitions def";
        if( $all_defs ) {
            $defs_table="definitions def";
        }

        my $sth = $dbh->prepare("
                SELECT v.word, def.definitionid, c.rafsi, c.selmaho, c.definition, c.notes, t.descriptor, u.username, u.realname
                FROM $defs_table
                JOIN valsi v
                ON v.valsiid = def.valsiid
                JOIN convenientdefinitions c
                ON c.definitionid = def.definitionid
                JOIN valsitypes t
                ON t.typeid = v.typeid
                JOIN users u
                ON u.userid = c.userid
                WHERE def.langid=$langid
                ORDER BY v.word");
        $sth->execute();

        return $sth;
      }

      sub selectwords {
          my ($dbh, $langid, $all_defs) = @_;

          my $defs_table="valsibestdefinitions def";
          if( $all_defs ) {
              $defs_table="definitions def";
          }

          my $sth = $dbh->prepare("
                  SELECT nlw.word, nlw.meaning, v.word AS valsi, nlwbg.place, def.definitionid
                  FROM $defs_table
                  JOIN valsi v
                  ON v.valsiid = def.valsiid
                  JOIN natlangwordbestguesses nlwbg
                  ON nlwbg.definitionid = def.definitionid
                  JOIN natlangwords nlw
                  ON nlw.wordid = nlwbg.natlangwordid
                  WHERE def.langid=$langid
                  ORDER BY valsi, nlw.word, nlw.meaning, nlwbg.place
                  ");
          $sth->execute();

          return $sth;
      }

      sub valsitag {
          my ($valsirows, $keywords, $positive_scores_only, $all_votes, $all_defs) = @_;
          my $valsirow = @$valsirows[0];

          my $tag .= "<valsi ";
          my $valsitype = $valsirow->{'descriptor'};
          if ($valsitype =~ /^(experimental|obsolete)/) {
            $tag .= $unofficialwarning;
          };
          $tag .= qq{word="}.$valsirow->{'word'}.qq{" type="$valsitype"};
          $tag .= ">";

          my $rafsis = massage( $valsirow->{'rafsi'} );
          $rafsis =~ s/\s+$//;
          $rafsis =~ s/^\s+//;
          $rafsis =~ s/\s+/ / ;
          if( $rafsis ) {
              foreach my $rafsi (split(/ /, $rafsis)) {
                  $tag .= "\n  <rafsi>$rafsi</rafsi>";
              }
          }

          if( $all_defs ) {
              $tag .= "\n  <definitions>";
          }

          # Save state to check for the case where no definitions are shown
          my $before_tag = $tag;

          foreach my $drow (@$valsirows) {

              my $definitionid = $drow->{'definitionid'};
              my $score = get_score($definitionid, $all_votes);

              if( $positive_scores_only && $score < 1 )
              {
                  next;
              }

              if( $all_defs ) {
                  $tag .= "\n    <definition>";
              }

              if( $drow->{'selmaho'} ) {
                  $tag .= "\n  <selmaho>" .
                    massage($drow->{'selmaho'})
                    . "</selmaho>";
              }

              $tag .= "\n  <user>" .
                  "\n    <username>" .
                  massage("$drow->{'username'}") .
                  "</username>";
              if( $drow->{'realname'} )
              {
                  $tag .= "\n    <realname>" .
                      massage("$drow->{'realname'}") .
                      "</realname>";
              }
              $tag .= "\n  </user>";

              my $def_tag;
              if( $all_defs ) {
                  $def_tag="text";
              } else {
                  $def_tag="definition";
              }

              $tag .= "\n      <$def_tag>" .
                  massage("$drow->{'definition'}") .
                  "</$def_tag>".
                  "\n      <definitionid>$definitionid</definitionid>";

              $tag .= "\n      <score>" . $score . "</score>";

              if( $drow->{'notes'} ) {
                  $tag .= "\n      <notes>".
                      massage($drow->{'notes'})
                      ."</notes>";
              }

              if( exists $keywords->{$definitionid} ) {
                  foreach my $keyword (sort {$a->{'place'} <=> $b->{'place'}} @{$keywords->{$definitionid}}) {
                      if ($keyword->{'place'} == 0) {
                          my $gwtag = glosswordtag($keyword);
                          $tag .= "\n      $gwtag";
                      }
                      else {
                          my $kwtag = keywordtag($keyword);
                          $tag .= "\n      $kwtag";
                      }
                  }
              }
              if( $all_defs ) {
                  $tag .= "\n    </definition>";
              }
          }

          if( $tag eq $before_tag )
          {
              # If no definitions were made visible, bail
              return "";
          }

          if( $all_defs ) {
              $tag .= "\n  </definitions>";
          }

          $tag .= "\n</valsi>";

          return $tag;
      }

      sub nlwordtag {
          my ($nlwrow, $positive_scores_only, $all_votes) = @_;

          # Check score
          my $score = get_score($nlwrow->{'definitionid'}, $all_votes);

          if( $positive_scores_only && $score < 1 )
          {
              return "";
          }

          my $tag .= "<nlword word=\"".
            massage($nlwrow->{'word'}) ."\"";

          if($nlwrow->{'meaning'} ) {
              $tag .= " sense=\"".
                massage($nlwrow->{'meaning'})
                ."\"";
          }

          $tag .= " valsi=\"" .
            massage($nlwrow->{'valsi'})
            . "\"";

          if($nlwrow->{'place'} > 0 ) {
              $tag .= " place=\"$nlwrow->{'place'}\"";
          }

          $tag .= " />";

          return $tag;
      }

      sub glosswordtag {
          my $keyword = shift;

          my $tag = "<glossword word=\"".
            massage($keyword->{'word'})
            ."\"";

          if ($keyword->{'meaning'}) {
              $tag .= " sense=\"".
                massage($keyword->{'meaning'}).
                "\""
          }

          $tag .= " />";

          return $tag;
      }

      sub keywordtag {
          my $keyword = shift;

          my $tag .= "<keyword word=\"".
            massage($keyword->{'word'})
            ."\" place=\"".
            $keyword->{'place'} .
            "\"";

          if ($keyword->{'meaning'}) {
              $tag .= " sense=\"".
                massage($keyword->{'meaning'}).
                "\""
          }

          $tag .= " />";

          return $tag;
      }

      sub dictcollate {
          my $to_be_ignored = $unofficialwarning;
          my $temp_a = $a;
          my $temp_b = $b;
          $temp_a =~ s/\Q$to_be_ignored\E//;
          $temp_b =~ s/\Q$to_be_ignored\E//;
          lc($temp_a) cmp lc($temp_b);
      }

      sub massage
      {
          my $input=shift(@_);
          $input =~ s/\&/\&amp;/g;  # This one *must* go first, or it'll redo the others
          $input =~ s/"/\&quot;/g;
          $input =~ s/'/\&apos;/g;
          $input =~ s/</\&lt;/g;
          $input =~ s/>/\&gt;/g;
          return $input;
      }
    } else {
	</%perl>
	<font size="+3">
	Captcha failed.  <pre><% Dumper($result) %>, <% $recaptcha_response %></pre>
	</font>
	<%perl>

    }
}

</%perl>
